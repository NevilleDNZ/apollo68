#!/usr/bin/algol68g-full --script #
# -*- coding: utf-8 -*- #
PR no-warning PR

PR include "prelude/scalar_:=_real.a68" PR;
PR include "prelude/with_trace_and_with_debug.a68" PR;
with trace := with debug := TRUE;
PR include "prelude/errata.a68" PR;
PR include "prelude/exception.a68" PR;

CO REQUIRED BY matrix CO
    PR include "prelude/math_errata.a68" PR;
PR include "prelude/matrix.a68" PR;

CO REQUIRED BY graph_2d CO
    FORMAT greal repr = $g(-0,2)$;
    MODE GREAL= REAL; # single precision #
    PR include "prelude/classes.a68" PR;
PR include "prelude/graph_2d.a68" PR;
STRING test plot dir = "test_plot/";
INT num of step size = 6; # was 5 #

CO REQUIRED BY ode_solve CO
    FORMAT r repr = real repr;
    FORMAT rn repr = vec repr;
    #FORMAT ty repr = $"t="f(r repr)" y="f(rn repr)$;#
    # PR include "prelude/math_hints.a68" PR; #
PR include "prelude/ode_order_1_solve.a68" PR;
PR include "prelude/linear_ode_order_n_solve.a68" PR;

# Note: [1]DNYBYDTN is dâ±y/dtâ± or simply dy/dt, whereas 
                [0]DNYBYDTN is dâ°y/dtâ° or simply y -- no differentiationâ€¦
                [-1]DNYBYDTN is dâ»â±y/dtâ»â± soâ€¦ -1 would be integration! #

CO
MODE IVPON = STRUCT(INTERVAL t interval, FLEX[1]DNYBYDTNO y0 dy0 ddy0 etc, FDNYBYDTN f dny by dtn);
MODE IVPONPKG = STRUCT(IVPON ivp, INTERVAL y axis, STRING description);
CO

# Pendulum initial conditions #
REAL m=1, s=1, g = 9.81 * m /s/s, pend l = 1*m, pend y0=0.1 * m, pend dy0 = 0;

# IMPORTANT NOTE: the "Order" of dâ¿y/dtâ¿ is IMPLIED by the number of boundary conditions!!! #
[]IVPONPKG test case list = (
#   t0,tn,y0,DNYBYDTN(t,y)                                             âŒŠ,âŒˆy, "Description" #
    #IVPON:#(
        (#x:#(0,1),
        []DNYBYDTNO( #y(0):#e**3, #dy/dt(0):#-54.6771157582462)[@0],  
        #dÂ²y/dtÂ²:#(REAL t, DNYBYDTNO y, DY dy by dt)DNYBYDTNO: 3*y-2*dy by dt
    ),
        #y:#(0,25), "y''=3y-2y', y(0)=e**3, y'(0)=1"),

    ((#x:#(0,1),[]VEC(#y(0):#1)[@0], #dy/dt:#(REAL t, DNYBYDTNO y)DNYBYDTNO:2*(t+1)*y[1]), (0,10),"dy/dt = 2(t+1)y, y(0)=1"),
    ((#x:#(0,1),[]VEC(#y(0):#1)[@0], #dy/dt:#(REAL t, DNYBYDTNO y)DNYBYDTNO:1 / y[1]**2 ), (0,2), "dy/dt = y**-2, y(0)=1"),
    ((#x:#(0,1),[]VEC(#y(0):#1)[@0], #dy/dt:#(REAL t, DNYBYDTNO y)DNYBYDTNO:t + y       ), (0,3), "dy/dt = t+y, y(0)=1")
    COMMENT suspect!,
CO cf. https://en.wikipedia.org/wiki/Pendulum_(mathematics)#Simple_gravity_pendulum CO

CO FDNYBYDTN dâ¿y/dtâ¿ = UNION(FY, FDY, FDDY, FDDDY, FDDDDY # ... #, FDNY); CO
   
    (
        #IVPON:#(
            # t: # (0, 3), # initial t and UPB of t #
            []DNYBYDTNO(#y(0):#RN(pend y0), #dy/dt(0):#RN(pend dy0))[@0], 
            # dÂ²y/dtÂ²: #(REAL t, DNYBYDTNO y, DY dy by dt)RN: RN(-g/pend l*sin(y[1]))
        ), 
        (-0.2,+0.2), "dÂ²y/dtÂ² = - g div l*sin(y) â€¦ Pendulum - o2"
    ),
    (
        #IVPON:# ( 
            # INTERVAL t interval:# 
                (0, 3), 
            # DNYBYDTNO y0 dy0 ddy0 ... d(n-1)y0:# 
                DNYBYDTNO( #y(0):#pend y0 ,# dy/dt(0):#pend dy0 )[@0], 
            # f dny by dtn OR dÂ²y/dtÂ²:# 
                (REAL t, DY dy)DNYBYDTNO: DNYBYDTNO(-g/pend l*dy[0], dy[1])[@0]
                # or (( 0        , 1)
                      (-g/l {sin}, 0)) x Dy[0]^T #
        ), 
        (-0.2,+0.2), "(dy/dt,dÂ²y/dtÂ²) â‰ˆ [ (0,1) , (-g div l*{sin},0) ] * (y,dy/dt)^T â€¦ Pendulum - order_1"
    ) END COMMENT
);

# Actual solutions #
[]FUNCTIONPKG test case solution list =(
    ((REAL t)DNYBYDTNO: (e**(3-3*t)*(4*e**(4*t)-1+e**4))/(3+e**4),   "y(t) = (e**(3-3*t)*(4*e**(4*t)-1+e**4))/(3+e**4)"),
    ((REAL t)DNYBYDTNO: 1/2*(t**2+2),   "y(t) = 1 over 2(t^2+2)"),
    ((REAL t)DNYBYDTNO: e**(t*(t+2)),   "y(t) = e^(t(t+2))"),
    ((REAL t)DNYBYDTNO: (3*t+1)**(1/3), "y(t) = (3x+1)^(1 by 3)"),
    ((REAL t)DNYBYDTNO: -t+2*e**t-1,    "y(t) = -t+2 e^t-1") COMMENT,
    ((REAL t)DNYBYDTNO: (pend y0*cos(sqrt(g/pend l)*t) #, y0*sin(sqrt(g/l)*t)#),
        "y(t) = y0 * cos(sqrt(g/l)*t) â€¦ Simplified Pendulum - o2"),
    ((REAL t)DNYBYDTNO: (pend y0*cos(sqrt(g/pend l)*t), pend y0*sin(sqrt(g/pend l)*t)),
        "y(t) = y0 * cos(sqrt(g/l)*t) â€¦ Simplified Pendulum - order_1") END COMMENT
);

# normalised Linear ODE: (1-D, order n)#
# fâ‚€(t)y + fâ‚(t)dy/dt + fâ‚‚(t)dÂ²y/dtÂ² + â‹¯ + fâ‚â‚™â‚‹â‚â‚(t)dâ¿y/dtâ¿ + b(t) = 0 #

# Linear ODE (vector Dim:m, Order:a,b,c,...,n):
  dáµƒyâ‚/dtáµƒ = fâ‚€(t)yâ‚ + fâ‚(t)dyâ‚/dt + fâ‚‚(t)dÂ²yâ‚/dtÂ² + â‹¯ + fâ‚â‚™â‚‹â‚â‚(t)dâ½áµƒ-Â¹â¾yâ‚/dtâ½áµƒ-Â¹â¾
  dáµ‡yâ‚‚/dtáµ‡ = fâ‚€(t)yâ‚‚ + fâ‚(t)dyâ‚‚/dt + fâ‚‚(t)dÂ²yâ‚‚/dtÂ² + â‹¯ + â‹¯ + fâ‚â‚™â‚‹â‚â‚(t)dâ½áµ‡-Â¹â¾yâ‚‚/dtâ½áµ‡-Â¹â¾
  dá¶œyâ‚ƒ/dtá¶œ = fâ‚€(t)yâ‚ƒ + fâ‚(t)dyâ‚ƒ/dt + fâ‚‚(t)dÂ²yâ‚ƒ/dtÂ² + â‹¯ + â‹¯ + â‹¯ + fâ‚â‚™â‚‹â‚â‚(t)dâ½á¶œ-Â¹â¾yâ‚ƒ/dtâ½á¶œ-Â¹â¾
         â‹®
  dâ¿yâ‚˜/dtâ¿ = fâ‚€(t)yâ‚˜ + fâ‚(t)dyâ‚˜/dt + fâ‚‚(t)dÂ²yâ‚˜/dtÂ² + â‹¯ + â‹¯ + â‹¯ + â‹¯ + fâ‚â‚™â‚‹â‚â‚(t)dâ½â¿-Â¹â¾yâ‚˜/dtâ½â¿-Â¹â¾

 Normalised Linear ODE (vector Dim:m, Order:n): 
  dâ¿yâ‚/dtâ¿ = fâ‚€(t)yâ‚ + fâ‚(t)dyâ‚/dt + fâ‚‚(t)dÂ²yâ‚/dtÂ² + â‹¯ + fâ‚â‚™â‚‹â‚â‚(t)dâ½â¿-Â¹â¾yâ‚/dtâ½â¿-Â¹â¾
  dâ¿yâ‚‚/dtâ¿ = fâ‚€(t)yâ‚‚ + fâ‚(t)dyâ‚‚/dt + fâ‚‚(t)dÂ²yâ‚‚/dtÂ² + â‹¯ + fâ‚â‚™â‚‹â‚â‚(t)dâ½â¿-Â¹â¾yâ‚‚/dtâ½â¿-Â¹â¾
  dâ¿yâ‚ƒ/dtâ¿ = fâ‚€(t)yâ‚ƒ + fâ‚(t)dyâ‚ƒ/dt + fâ‚‚(t)dÂ²yâ‚ƒ/dtÂ² + â‹¯ + fâ‚â‚™â‚‹â‚â‚(t)dâ½â¿-Â¹â¾yâ‚ƒ/dtâ½â¿-Â¹â¾
           â‹®
  dâ¿yâ‚˜/dtâ¿ = fâ‚€(t)yâ‚˜ + fâ‚(t)dyâ‚˜/dt + fâ‚‚(t)dÂ²yâ‚˜/dtÂ² + â‹¯ + fâ‚â‚™â‚‹â‚â‚(t)dâ½â¿-Â¹â¾yâ‚˜/dtâ½â¿-Â¹â¾

Let: Vector ğ•ª = ( yâ‚, yâ‚‚, yâ‚ƒ, â‹¯, yâ‚˜ ) Â¢ a Vector of Scalar from â‚ to â‚˜ Â¢

With Initial Conditions:

Let: Vector ğ•ªâ‚€ = ( yâ‚(tâ‚€),  yâ‚‚(tâ‚€),  yâ‚‚(tâ‚€), â‹¯, yâ‚˜(tâ‚€) ) Â¢ a Vector of Scalar values from â‚ to â‚˜ Â¢

Key-point: â‚˜ is not necessarily equal to â¿
  - â‚˜ is the dimension of the problem vector space.
  - â¿ is the Order of the Differential Equation.

[A] Using Vector "ğ•ª" we get same Order:n vector differential function dâ¿ğ•ª/dtâ¿ as:
  dâ¿ğ•ª/dtâ¿  = fâ‚€(t)ğ•ª  + fâ‚(t)dğ•ª/dt  + fâ‚‚(t)dÂ²ğ•ª/dtÂ²  + â‹¯ + fâ‚â‚™â‚‹â‚â‚(t)dâ½â¿-Â¹â¾ğ•ª/dtâ½â¿-Â¹â¾


Now we with this above Order:n Linear ODE (ğ•ª is Dim:n) we need to convert to Order:1: 

Using [A] we can get an Order:1 linear ordinary differential equation as follows.

Stack up the known equations as follows:
  dğ•ª/dt           = Org +    dğ•ª/dt
  dÂ²ğ•ª/dtÂ²         = Org +    Org +    dÂ²ğ•ª/dtÂ²
  dÂ³ğ•ª/dtÂ³         = Org +    Org +    Org +    dÂ³ğ•ª/dtÂ³
                     â‹®       â‹®        â‹®               â‹±
  dâ½â¿-Â²â¾ğ•ª/dtâ½â¿-Â²â¾ = Org +    Org +    Org +    â‹¯ + Org + â‹¯ + dâ½â¿-Â²â¾ğ•ª/dtâ½â¿-Â²â¾
  dâ½â¿-Â¹â¾ğ•ª/dtâ½â¿-Â¹â¾ = Org +    Org +    Org +    â‹¯ + Org + â‹¯ + Org + dâ½â¿-Â¹â¾ğ•ª/dtâ½â¿-Â¹â¾
  dâ¿ğ•ª/dtâ¿         = fâ‚€(t)ğ•ª + fâ‚(t)dğ•ª/dt + fâ‚‚(t)dÂ²ğ•ª/dtÂ² + â‹¯ + fâ‚â‚™â‚‹â‚â‚(t)dâ½â¿-Â¹â¾ğ•ª/dtâ½â¿-Â¹â¾

Represent this in matrix form:
let A(t) = ((  Org,    1s,   Org,   Org,      â‹¯,    Org,       Org,      Org),
            (  Org,   Org,    1s,   Org,      â‹¯,    Org,       Org,      Org),
            (  Org,   Org,   Org,    1s,      â‹¯,    Org,       Org,      Org),
                 â‹®     â‹®     â‹®      â‹®      â‹±      â‹®         â‹®         â‹®
            (  Org,   Org,   Org,   Org,      â‹¯,     1s,       Org,      Org),
            (  Org,   Org,   Org,   Org,      â‹¯,    Org,        1s,      Org),
            (  Org,   Org,   Org,   Org,      â‹¯,    Org,       Org,       1s),
            (fâ‚€(t), fâ‚(t), fâ‚‚(t), fâ‚ƒ(t),   â‹¯, fâ‚â‚™â‚‹â‚ƒâ‚(t), fâ‚â‚™â‚‹â‚‚â‚(t), fâ‚â‚™â‚‹â‚â‚(t)) )

Define: Matrix ğ•(ğ•ª) = ( ğ•ª, dğ•ª/dt, dÂ²ğ•ª/dtÂ², â‹¯, dâ½â¿-Â¹â¾ğ•ª/dtâ½â¿-Â¹â¾ )
  Â¢ a Vector of Vector of differentials from â° to â½â¿-Â¹â¾Â¢

We get: dğ•(ğ•ª)/dt = A(ğ•ª) Ã— (ğ•ª, dğ•ª/dt, dÂ²ğ•ª/dtÂ² â‹¯, dâ½â¿-Â¹â¾ğ•ª/dtâ½â¿-Â¹â¾, dâ¿ğ•ª/dtâ¿)áµ€
                = A(ğ•ª) Ã— ğ•(ğ•ª)áµ€

So we now have a Order:1 Linear Ordinary Differential equation to solve.
#

PR include "prelude/curve.a68" PR;

PROC f crude tol portal = (TY ty)DNYBYDTNO: ABS y OF ty * 10 + 10; # some big number #

PROC(REAL)DY actual = function OF test case solution list[1];

r5_1: (
    print(("Phase 1:",68*"-", new line));

    PROC plot solutions = (ODEONSOLVEPKG solve, IVPONPKG ivp pkg, FUNCTIONPKG test case solution)DNYBYDTNO: (
        ### return calculated solution ###
        REF GRAPHDD graph := INIT LOC GRAPHDD;

        IVPON ivp = ivp OF ivp pkg;

        STRING title, sub title;

        prefix OF graph := test plot dir;
        title OF graph := title := "Solution of "+description OF ivp pkg+" (Actual(dashed) vs Calculated)";
        type OF window OF graph := "gif"; # or gif, ps, T, pnm etc #
        sub title OF graph := sub title := "Using: "+description OF solve;
        printf(($gl$,title, sub title));

        interval OF axis OF graph := (t interval OF ivp, y axis OF ivp pkg);

        ODEONSOLVETYNGEN solution tyn gen = method tyn gen OF solve;

        printf($l"*** KEY: (step size vs colour)"l$);
        (begin curve OF (METHODOF graph))(~);
        FOR k FROM 0 TO num of step size-1 DO
            REAL step size = 0.2 / 2 ** k;
    (with debug|printf(($"DB - k: "$,$f(int repr)"; "$,k)));
    (with debug|printf(($"DB - step: "$,$f(real repr)"; "$,step size,$l$)));
      
            ODEONSOLVEARGS args = (step size, f crude tol portal);
            #POINT#DDGEN curve = gen filter tyn to 2d(solution tyn gen(ivp, args,),lwb y,);
            (with debug|print gen 2d table(title+"+"+sub title+":",curve));
            (add curve OF (METHODOF graph))(curve, rainbow[k+1]);
            printf(($"**** "g(-8,6)" = "gl$, step size, (name OF rainbow[k + 1])))
        OD;
        INT num samples = 20;
        #POINT#DDGEN actual solution gen = gen function curve(function OF test case solution, t interval OF ivp, num samples, );
        (add curve OF (METHODOF graph))(actual solution gen, (black, dotted));
        (end curve OF (METHODOF graph))(~);
        SKIP # some how need to snatch the solution at the end of the t interval #
    );

    FOR n test TO UPB test case list DO
        IF FALSE AND n test = UPB test case list THEN # specific tests #
            debug
        FI;
        IF TRUE OR n test = 2 THEN # specific tests #
            IVPONPKG test case = test case list[n test];
            print ode ivp order n(description OF test case, ivp OF test case);
            printf(($"* Test case "g(-0)" "gl$, n test, description OF test case));
            DNYBYDTNO actual solution = (function OF test case solution list[n test])(upb OF t interval OF ivp OF test case);
            printf(($"*** actual solution: "g$, REPR actual solution,$l$));
            FOR n solve TO UPB ode order n solve list DO
                ODEONSOLVEPKG solve := ode order n solve list[n solve];
                printf(($"** Test solver "g(-0)" "gl$, n solve, description OF solve));
                DNYBYDTNO calculated solution = plot solutions(solve, test case, test case solution list[n test]);
            # Currently calculated solution is only returned as SKIP #
                (FALSE|printf(($"*** calculated solution: ("$,$n(UPB calculated solution)(g)$, calculated solution,$")"l$)))
            OD
        FI
    OD
);

r5_1 analyse errors: (

    print(("*Phase 2:",68*"-", new line));
# define the bounds of the 'log error' vs 'log step size' graph #
    INTERVAL log step sizes = (ENTIER(log(0.2 / 2**5)), 1 + ENTIER(log(0.2 / 2**0)));
    INTERVAL log error = (-real width OVER 2, 1);

    PROC gen step size = (REALYIELD yield)VOID:
        FOR k FROM 0 TO num of step size-1 DO yield(0.2 / 2**k) OD;

    PROC gen error vs stepsize = (ODEONSOLVEPKG solve, IVPON ivp, RN actual solution, RNYIELD yield)VOID: (

        ODEONSOLVETYNGEN solution tyn gen = method tyn gen OF solve;
        # FOR INT step size IN # gen step size(#DO)#
        ##   (REAL step size)VOID:(
                      ODEONSOLVEARGS args = (step size, f crude tol portal);
                      DY dny by dtn = (y OF get tail tyn(solution tyn gen(ivp, args,)))[lwb y];
        # recall: The first entry in dâ¿y/dtâ¿ is actually y #
                      print((REPR dny by dtn, new line));
                      DNYBYDTNO y = dny by dtn[:UPB actual solution];
                      yield((log(step size), log(ABS(y - actual solution)[1]))) # NB: ignoring y[2] â€¦ #
        # OD #))

    );

    PROC plot error vs step size = (IVPONPKG ivp pkg, FUNCTIONPKG test case solution)VOID:(
        IVPON ivp = ivp OF ivp pkg;
        REF GRAPHDD graph := INIT LOC GRAPHDD;

        prefix OF graph := test plot dir;
        title OF graph := "Solution of "+description OF ivp pkg;
        sub title OF graph := "(log error vs log step size for the various ODE solvers)";

        type OF window OF graph := "gif"; # or gif, ps, T, pnm etc #
        #sub title OF graph := "Using: "+description OF solve;#

        interval OF axis OF graph := (log step sizes # vs #, log error);
        label OF axis OF graph := ("log step sizes" # vs #, "log error");

        RN actual solution = (function OF test case solution)(upb OF t interval OF ivp);

        (begin curve OF (METHODOF graph))(~);

        printf($l"*** Key: (method vs colour)"l$);
        FOR n solve TO #1 + 0 * QQQ#UPB ode order n solve list DO
            ODEONSOLVEPKG solve := ode order n solve list[n solve];
            printf(($"*      "g(-0)" "g":"l$, n solve, description OF solve));
            RNGEN gen error curve = gen error vs stepsize(solve, ivp, actual solution,);
            (add curve OF (METHODOF graph))(gen error curve, rainbow[n solve]);
            printf(($g": "gl$, description OF solve, (name OF rainbow[n solve])))
        OD;

        (end curve OF (METHODOF graph))(~)
    );

# first compare 'error' to 'step size' of individual methods #
    FOR n test TO #1 + 0 * QQQ#UPB test case list DO
        IVPONPKG test case = test case list[n test];
        printf(($"** Test case "g(-0)" "gl$, n test, description OF test case));
        plot error vs step size(test case, test case solution list[n test])
    OD

);
PR include "postlude/exception.a68" PR;
PR include "postlude/scalar_=:_real.a68" PR
